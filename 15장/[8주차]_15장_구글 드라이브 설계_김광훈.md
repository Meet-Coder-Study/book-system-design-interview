# 14장. 구글 드라이브 설계
## 1. 요구 사항
- (1)파일 추가
- (2) 파일 다운로드
- (3) 여러 단말에 파일 동기화
- (4) 파일 갱신 이력 조회
- (5) 파일 공유
- (6) 파일 편집 & 삭제 알림 표시

<br>

## 2. API
- (1) 파일 업로드 API
- (2) 파일 다운로드 API
- (3) 파일 갱신 히스토리 API

<br>

## 3. 한 대 서버의 제약 극복
![image](https://user-images.githubusercontent.com/60383031/160762888-adf2d4e9-e6aa-4705-842e-b945c2629ba4.png)


- 로드밸런서: 트래픽 분산
- 웹 서버: 로드밸런서가 있다면, 웹 서버 쉽게 추가 가능
- 메타데이터 DB: 파일 저장 서버에서 분리 -> SPOF 회피 -> + 다중화, 샤딩 -> 가용성, 규모 확장 대응
- 파일 저장소: S3 저장소 사용 -> 두 개 이상의 지역에 데이터를 다중화

<br>

## 4. 동기화 충돌
- 버전으로 해결한다.
- 즉 두 가지 버전 중 합칠지 아니면 대체할지 결정한다.

<br>

## 5. 블록 저장소 서버
![image](https://user-images.githubusercontent.com/60383031/160762941-7ec158ab-4e52-4866-a003-2cc34328dc5a.png)


![image](https://user-images.githubusercontent.com/60383031/160763050-5b8196a1-2f84-415f-8b89-335864954069.png)


- 파일 블록을 클라우드 저장소에 업로드하는 서버
- 파일 하나를 여러개의 블록으로 나눠 저장 -> 각 블록 고유 해시값 할당 
- Example) S3


#### (1) 델타 동기화
- 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화 

#### (2) 압축 
- 블록 단위로 압축하면 데이터 크기를 많이 줄일 수 있다.
- 압축 알고리즘: gzip, bzip2 등

<br>

## 6. 높은 일관성 요구사항
- 강한 일관성 모델(strong consistency)을 기본으로 한다.
- 같은 파일이 단말이나 사용자에 따라 다르게 보이는 것은 허용할 수 없다.
- 메타데이터 캐시와 데이터베이스 계층에서 같은 원칙이 적용되어야함
- 메모리 캐시는 보통 최종 일관성(eventual consistency) 모델을 지원한다. -> ACID 지원 x -> 애플리케이션에서 구현
- 따라서 추가 요구 사항을 만족시켜야 한다.
    - 캐시는 데이터베이스에 있는 원본과 일치
    - 원본 변경 -> 캐시 데이터 무효 

<br>

## 6. 알림 서비스
- 이벤트 데이터를 클라이언트들로 보내는 서비스
- 알림 서비스 구현으로 아래 두 가지 선택지가 았음 
- 책에서는 롤 폴링 채택, 양방향 통신은 필요가 없기 떄문에

#### (1) 롱 폴링 (long polling)
- 드롭박스가 채택하는 방식
- 각 클라이언트는 알림 서버와 롱 폴링용 연결을 유지
- 특정 파일에 대한 변경 감지 -> connection 끊음
- 이때 클라이언트는 반드시 메타데이터 서버와 연결해 파일의 초신 내역을 다운로드 한다.
- 다운로드 작업이 끝나거나 timeout 시간이 되면 새 요청을 보내어 롱 폴링 연결을 복원 및 유지

#### (2) 웹 소켓 
- 클라이언트 <--> 서버 

<br>

## 7. 저장소 공간 절약
#### (1) 중복 재거
- 해쉬 값을 비교하여 중복 데이터를 제거한다.

#### (2) 지능적 백업 전략 도입
- 파일 버전 개수에 상한을 둔다.
- 중요한 버전만 보관한다. -> 자주 수정되는 파일은 불필요한 버전을 많이 생성한다.

#### (3) 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다.
- 아마존 S3 글래시어같은 아카이빙 저장소를 사용한다.


